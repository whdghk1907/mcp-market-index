# üìä ÏãúÏû• ÏßÄÏàò MCP ÏÑúÎ≤Ñ Í∞úÎ∞ú Í≥ÑÌöçÏÑú

## 1. ÌîÑÎ°úÏ†ùÌä∏ Í∞úÏöî

### 1.1 Î™©Ï†Å
Ïã§ÏãúÍ∞Ñ ÌïúÍµ≠ Ï£ºÏãùÏãúÏû• ÏßÄÏàò(ÏΩîÏä§Ìîº/ÏΩîÏä§Îã•) Îç∞Ïù¥ÌÑ∞Î•º Ï†úÍ≥µÌïòÎäî MCP ÏÑúÎ≤Ñ Íµ¨Ï∂ï

### 1.2 Î≤îÏúÑ
- ÏΩîÏä§Ìîº/ÏΩîÏä§Îã• ÌòÑÏû¨ ÏßÄÏàò Î∞è Îì±ÎùΩÎ•†
- ÏßÄÏàò Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ (ÏùºÏ§ë/ÏùºÎ≥Ñ/Ï£ºÎ≥Ñ/ÏõîÎ≥Ñ)
- ÏãúÏû• Ï†ÑÏ≤¥ ÏöîÏïΩ Ï†ïÎ≥¥ (Í±∞ÎûòÎüâ, Í±∞ÎûòÎåÄÍ∏à, ÏãúÍ∞ÄÏ¥ùÏï°)
- ÏóÖÏ¢ÖÎ≥Ñ ÏßÄÏàò Ï†ïÎ≥¥

### 1.3 Í∏∞Ïà† Ïä§ÌÉù
- **Ïñ∏Ïñ¥**: Python 3.11+
- **MCP SDK**: mcp-python
- **API Client**: ÌïúÍµ≠Ìà¨ÏûêÏ¶ùÍ∂å OpenAPI
- **ÎπÑÎèôÍ∏∞ Ï≤òÎ¶¨**: asyncio, aiohttp
- **Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù**: pydantic
- **Ï∫êÏã±**: ÎÇ¥Ïû• Î©îÎ™®Î¶¨ Ï∫êÏãú

## 2. ÏÑúÎ≤Ñ ÏïÑÌÇ§ÌÖçÏ≤ò

```
mcp-market-index/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ server.py           # MCP ÏÑúÎ≤Ñ Î©îÏù∏
‚îÇ   ‚îú‚îÄ‚îÄ tools/              # MCP ÎèÑÍµ¨ Ï†ïÏùò
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index_tools.py  # ÏßÄÏàò Í¥ÄÎ†® ÎèÑÍµ¨
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ market_tools.py # ÏãúÏû• ÏöîÏïΩ ÎèÑÍµ¨
‚îÇ   ‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.py       # ÌïúÍµ≠Ìà¨ÏûêÏ¶ùÍ∂å API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ models.py       # Îç∞Ïù¥ÌÑ∞ Î™®Îç∏
‚îÇ   ‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cache.py        # Ï∫êÏãú Í¥ÄÎ¶¨
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ formatter.py    # Îç∞Ïù¥ÌÑ∞ Ìè¨Îß∑ÌåÖ
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validator.py    # Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù
‚îÇ   ‚îî‚îÄ‚îÄ config.py           # ÏÑ§Ï†ï Í¥ÄÎ¶¨
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ test_tools.py
‚îÇ   ‚îî‚îÄ‚îÄ test_api.py
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .env.example
‚îî‚îÄ‚îÄ README.md
```

## 3. ÌïµÏã¨ Í∏∞Îä• Î™ÖÏÑ∏

### 3.1 Ï†úÍ≥µ ÎèÑÍµ¨ (Tools)

#### 1) `get_market_index`
```python
@tool
async def get_market_index(market: Literal["KOSPI", "KOSDAQ", "ALL"] = "ALL") -> dict:
    """
    ÌòÑÏû¨ ÏãúÏû• ÏßÄÏàò Ï°∞Ìöå
    
    Parameters:
        market: Ï°∞ÌöåÌï† ÏãúÏû• (KOSPI, KOSDAQ, ALL)
    
    Returns:
        {
            "timestamp": "2024-01-10T10:30:00+09:00",
            "kospi": {
                "current": 2500.50,
                "change": 15.30,
                "change_rate": 0.61,
                "volume": 450000000,
                "amount": 8500000000000,
                "high": 2510.20,
                "low": 2485.30,
                "open": 2490.00
            },
            "kosdaq": {
                "current": 850.25,
                "change": -5.10,
                "change_rate": -0.60,
                "volume": 850000000,
                "amount": 5200000000000,
                "high": 855.00,
                "low": 848.50,
                "open": 853.00
            }
        }
    """
```

#### 2) `get_index_chart`
```python
@tool
async def get_index_chart(
    market: Literal["KOSPI", "KOSDAQ"], 
    period: Literal["1D", "1W", "1M", "3M", "1Y"] = "1D",
    interval: Literal["1m", "5m", "30m", "1h", "1d"] = "5m"
) -> dict:
    """
    ÏßÄÏàò Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
    
    Parameters:
        market: ÏãúÏû• Íµ¨Î∂Ñ
        period: Ï°∞Ìöå Í∏∞Í∞Ñ
        interval: Îç∞Ïù¥ÌÑ∞ Í∞ÑÍ≤©
    
    Returns:
        {
            "market": "KOSPI",
            "period": "1D",
            "interval": "5m",
            "data": [
                {
                    "timestamp": "2024-01-10T09:00:00+09:00",
                    "open": 2490.00,
                    "high": 2492.50,
                    "low": 2488.00,
                    "close": 2491.20,
                    "volume": 15000000
                },
                ...
            ]
        }
    """
```

#### 3) `get_market_summary`
```python
@tool
async def get_market_summary() -> dict:
    """
    ÏãúÏû• Ï†ÑÏ≤¥ ÏöîÏïΩ Ï†ïÎ≥¥ Ï°∞Ìöå
    
    Returns:
        {
            "timestamp": "2024-01-10T10:30:00+09:00",
            "kospi": {
                "advancing": 450,
                "declining": 380,
                "unchanged": 95,
                "trading_halt": 5,
                "limit_up": 12,
                "limit_down": 3,
                "new_high_52w": 8,
                "new_low_52w": 2,
                "market_cap": 2100000000000000,  # Ï°∞ Îã®ÏúÑ
                "foreign_ownership_rate": 31.5
            },
            "kosdaq": {
                "advancing": 750,
                "declining": 620,
                "unchanged": 180,
                "trading_halt": 8,
                "limit_up": 25,
                "limit_down": 5,
                "new_high_52w": 15,
                "new_low_52w": 7,
                "market_cap": 450000000000000,
                "foreign_ownership_rate": 8.2
            }
        }
    """
```

#### 4) `get_sector_indices`
```python
@tool
async def get_sector_indices(market: Literal["KOSPI", "KOSDAQ"] = "KOSPI") -> dict:
    """
    ÏóÖÏ¢ÖÎ≥Ñ ÏßÄÏàò Ï°∞Ìöå
    
    Parameters:
        market: ÏãúÏû• Íµ¨Î∂Ñ
    
    Returns:
        {
            "market": "KOSPI",
            "timestamp": "2024-01-10T10:30:00+09:00",
            "sectors": [
                {
                    "name": "Î∞òÎèÑÏ≤¥",
                    "code": "G2510",
                    "current": 3250.50,
                    "change": 45.20,
                    "change_rate": 1.41,
                    "volume": 25000000,
                    "amount": 850000000000
                },
                {
                    "name": "ÏùÄÌñâ",
                    "code": "G2710",
                    "current": 850.30,
                    "change": -2.10,
                    "change_rate": -0.25,
                    "volume": 8500000,
                    "amount": 120000000000
                },
                ...
            ]
        }
    """
```

#### 5) `get_market_compare`
```python
@tool
async def get_market_compare(
    date_from: str = None,
    date_to: str = None
) -> dict:
    """
    ÏãúÏû• ÏßÄÏàò ÎπÑÍµê (Í∏∞Í∞ÑÎ≥Ñ Î≥ÄÌôî)
    
    Parameters:
        date_from: ÏãúÏûëÏùº (YYYY-MM-DD)
        date_to: Ï¢ÖÎ£åÏùº (YYYY-MM-DD)
    
    Returns:
        {
            "period": {
                "from": "2024-01-01",
                "to": "2024-01-10"
            },
            "kospi": {
                "start": 2450.00,
                "end": 2500.50,
                "change": 50.50,
                "change_rate": 2.06,
                "high": 2520.00,
                "low": 2440.00,
                "avg_volume": 380000000,
                "avg_amount": 7500000000000
            },
            "kosdaq": {
                "start": 830.00,
                "end": 850.25,
                "change": 20.25,
                "change_rate": 2.44,
                "high": 865.00,
                "low": 825.50,
                "avg_volume": 750000000,
                "avg_amount": 4800000000000
            }
        }
    """
```

## 4. API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Íµ¨ÌòÑ

### 4.1 ÌïúÍµ≠Ìà¨ÏûêÏ¶ùÍ∂å API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏

```python
# src/api/client.py
import aiohttp
import asyncio
from typing import Dict, Optional
from datetime import datetime, timedelta
import hashlib
import json

class KoreaInvestmentAPI:
    def __init__(self, app_key: str, app_secret: str):
        self.app_key = app_key
        self.app_secret = app_secret
        self.base_url = "https://openapi.koreainvestment.com:9443"
        self.access_token = None
        self.token_expires = None
        
    async def _get_access_token(self):
        """Ïï°ÏÑ∏Ïä§ ÌÜ†ÌÅ∞ Î∞úÍ∏â/Í∞±Ïã†"""
        if self.access_token and self.token_expires > datetime.now():
            return self.access_token
            
        headers = {"content-type": "application/json"}
        body = {
            "grant_type": "client_credentials",
            "appkey": self.app_key,
            "appsecret": self.app_secret
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.base_url}/oauth2/tokenP",
                headers=headers,
                json=body
            ) as resp:
                data = await resp.json()
                self.access_token = data["access_token"]
                self.token_expires = datetime.now() + timedelta(seconds=data["expires_in"])
                
        return self.access_token
    
    async def get_index_price(self, index_code: str) -> Dict:
        """ÏßÄÏàò ÌòÑÏû¨Í∞Ä Ï°∞Ìöå"""
        token = await self._get_access_token()
        
        headers = {
            "authorization": f"Bearer {token}",
            "appkey": self.app_key,
            "appsecret": self.app_secret,
            "tr_id": "FHKUP03500100"
        }
        
        params = {
            "FID_COND_MRKT_DIV_CODE": "U",
            "FID_INPUT_ISCD": index_code  # 0001: KOSPI, 1001: KOSDAQ
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.get(
                f"{self.base_url}/uapi/domestic-stock/v1/quotations/inquire-index-price",
                headers=headers,
                params=params
            ) as resp:
                return await resp.json()
    
    async def get_index_chart_data(
        self, 
        index_code: str, 
        period_div_code: str,
        input_date: str = ""
    ) -> Dict:
        """ÏßÄÏàò Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå"""
        token = await self._get_access_token()
        
        headers = {
            "authorization": f"Bearer {token}",
            "appkey": self.app_key,
            "appsecret": self.app_secret,
            "tr_id": "FHKUP03500200"
        }
        
        params = {
            "FID_COND_MRKT_DIV_CODE": "U",
            "FID_INPUT_ISCD": index_code,
            "FID_PERIOD_DIV_CODE": period_div_code,
            "FID_INPUT_DATE_1": input_date
        }
        
        async with aiohttp.ClientSession() as session:
            async with session.get(
                f"{self.base_url}/uapi/domestic-stock/v1/quotations/inquire-index-chart-price",
                headers=headers,
                params=params
            ) as resp:
                return await resp.json()
```

## 5. Ï∫êÏã± Ï†ÑÎûµ

```python
# src/utils/cache.py
from typing import Dict, Any, Optional
from datetime import datetime, timedelta
import asyncio

class MarketDataCache:
    def __init__(self):
        self._cache: Dict[str, Dict[str, Any]] = {}
        self._locks: Dict[str, asyncio.Lock] = {}
        
    async def get_or_fetch(
        self, 
        key: str, 
        fetch_func, 
        ttl: int = 5  # Í∏∞Î≥∏ 5Ï¥à Ï∫êÏãú
    ) -> Any:
        """Ï∫êÏãúÏóêÏÑú Í∞ÄÏ†∏Ïò§Í±∞ÎÇò ÏÉàÎ°ú fetch"""
        # Ï∫êÏãú ÌôïÏù∏
        if key in self._cache:
            cached = self._cache[key]
            if cached['expires'] > datetime.now():
                return cached['data']
        
        # LockÏùÑ ÏÇ¨Ïö©Ìï¥ Ï§ëÎ≥µ ÏöîÏ≤≠ Î∞©ÏßÄ
        if key not in self._locks:
            self._locks[key] = asyncio.Lock()
            
        async with self._locks[key]:
            # Îã§Ïãú ÌïúÎ≤à Ï∫êÏãú ÌôïÏù∏ (race condition Î∞©ÏßÄ)
            if key in self._cache:
                cached = self._cache[key]
                if cached['expires'] > datetime.now():
                    return cached['data']
            
            # ÏÉàÎ°ú fetch
            data = await fetch_func()
            
            # Ï∫êÏãú Ï†ÄÏû•
            self._cache[key] = {
                'data': data,
                'expires': datetime.now() + timedelta(seconds=ttl)
            }
            
            return data
    
    def invalidate(self, key: str = None):
        """Ï∫êÏãú Î¨¥Ìö®Ìôî"""
        if key:
            self._cache.pop(key, None)
        else:
            self._cache.clear()
    
    def get_stats(self) -> Dict[str, Any]:
        """Ï∫êÏãú ÌÜµÍ≥Ñ Î∞òÌôò"""
        total_keys = len(self._cache)
        valid_keys = sum(1 for v in self._cache.values() 
                        if v['expires'] > datetime.now())
        
        return {
            'total_keys': total_keys,
            'valid_keys': valid_keys,
            'expired_keys': total_keys - valid_keys
        }
```

## 6. ÏóêÎü¨ Ï≤òÎ¶¨ Î∞è Ïû¨ÏãúÎèÑ

```python
# src/utils/retry.py
import asyncio
from functools import wraps
from typing import TypeVar, Callable, Union
import logging

T = TypeVar('T')
logger = logging.getLogger(__name__)

class APIError(Exception):
    """API Ìò∏Ï∂ú Í¥ÄÎ†® ÏóêÎü¨"""
    pass

class RateLimitError(APIError):
    """Rate Limit ÏóêÎü¨"""
    pass

def retry_on_error(
    max_attempts: int = 3, 
    delay: float = 1.0,
    backoff: float = 2.0,
    exceptions: tuple = (APIError,)
):
    """API Ìò∏Ï∂ú Ïû¨ÏãúÎèÑ Îç∞ÏΩîÎ†àÏù¥ÌÑ∞"""
    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        @wraps(func)
        async def wrapper(*args, **kwargs) -> T:
            last_exception = None
            attempt_delay = delay
            
            for attempt in range(max_attempts):
                try:
                    return await func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    
                    if isinstance(e, RateLimitError):
                        # Rate limitÏùò Í≤ΩÏö∞ Îçî Í∏¥ ÎåÄÍ∏∞
                        attempt_delay = 60.0
                    
                    logger.warning(
                        f"Attempt {attempt + 1}/{max_attempts} failed: {str(e)}"
                    )
                    
                    if attempt < max_attempts - 1:
                        await asyncio.sleep(attempt_delay)
                        attempt_delay *= backoff
                    else:
                        logger.error(f"All {max_attempts} attempts failed")
                        raise
                        
            raise last_exception
            
        return wrapper
    return decorator
```

## 7. Íµ¨ÌòÑ ÏùºÏ†ï

### Phase 1: Í∏∞Ï¥à Íµ¨ÌòÑ (3Ïùº)
- [ ] ÌîÑÎ°úÏ†ùÌä∏ Íµ¨Ï°∞ ÏÑ§Ï†ï
- [ ] MCP ÏÑúÎ≤Ñ Í∏∞Î≥∏ ÏÑ§Ï†ï
- [ ] ÌïúÍµ≠Ìà¨ÏûêÏ¶ùÍ∂å API ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Íµ¨ÌòÑ
- [ ] Í∏∞Î≥∏ ÏßÄÏàò Ï°∞Ìöå ÎèÑÍµ¨ Íµ¨ÌòÑ

### Phase 2: ÌïµÏã¨ Í∏∞Îä• (4Ïùº)
- [ ] Î™®Îì† ÎèÑÍµ¨(tools) Íµ¨ÌòÑ
- [ ] Ï∫êÏã± ÏãúÏä§ÌÖú Íµ¨ÌòÑ
- [ ] ÏóêÎü¨ Ï≤òÎ¶¨ Î∞è Ïû¨ÏãúÎèÑ Î°úÏßÅ
- [ ] Îç∞Ïù¥ÌÑ∞ Ìè¨Îß∑ÌåÖ Î∞è Í≤ÄÏ¶ù

### Phase 3: Í≥†ÎèÑÌôî (3Ïùº)
- [ ] ÏÑ±Îä• ÏµúÏ†ÅÌôî
- [ ] Î°úÍπÖ ÏãúÏä§ÌÖú
- [ ] Îã®ÏúÑ ÌÖåÏä§Ìä∏ ÏûëÏÑ±
- [ ] Î¨∏ÏÑúÌôî

## 8. ÌÖåÏä§Ìä∏ Í≥ÑÌöç

### 8.1 Îã®ÏúÑ ÌÖåÏä§Ìä∏
```python
# tests/test_tools.py
import pytest
from src.tools.index_tools import get_market_index
from src.utils.cache import MarketDataCache

@pytest.mark.asyncio
async def test_get_market_index():
    """ÏãúÏû• ÏßÄÏàò Ï°∞Ìöå ÌÖåÏä§Ìä∏"""
    result = await get_market_index("ALL")
    
    assert "kospi" in result
    assert "kosdaq" in result
    assert "timestamp" in result
    
    # KOSPI Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù
    kospi = result["kospi"]
    assert all(key in kospi for key in ["current", "change", "change_rate"])
    assert isinstance(kospi["current"], float)
    assert kospi["current"] > 0

@pytest.mark.asyncio
async def test_cache_functionality():
    """Ï∫êÏãú Í∏∞Îä• ÌÖåÏä§Ìä∏"""
    cache = MarketDataCache()
    
    call_count = 0
    async def fetch_func():
        nonlocal call_count
        call_count += 1
        return {"data": "test"}
    
    # Ï≤´ Ìò∏Ï∂ú
    result1 = await cache.get_or_fetch("test_key", fetch_func, ttl=1)
    assert call_count == 1
    
    # Ï∫êÏãúÎêú Îç∞Ïù¥ÌÑ∞ Î∞òÌôò
    result2 = await cache.get_or_fetch("test_key", fetch_func, ttl=1)
    assert call_count == 1  # fetch_funcÏù¥ Îã§Ïãú Ìò∏Ï∂úÎêòÏßÄ ÏïäÏùå
    assert result1 == result2
    
    # TTL ÎßåÎ£å ÌõÑ
    await asyncio.sleep(1.1)
    result3 = await cache.get_or_fetch("test_key", fetch_func, ttl=1)
    assert call_count == 2  # fetch_funcÏù¥ Îã§Ïãú Ìò∏Ï∂úÎê®
```

### 8.2 ÌÜµÌï© ÌÖåÏä§Ìä∏
- API Ïó∞Îèô ÌÖåÏä§Ìä∏
- Ï∫êÏãú ÎèôÏûë ÌÖåÏä§Ìä∏
- ÏóêÎü¨ ÏãúÎÇòÎ¶¨Ïò§ ÌÖåÏä§Ìä∏
- Î∂ÄÌïò ÌÖåÏä§Ìä∏

## 9. Î∞∞Ìè¨ Î∞è Ïö¥ÏòÅ

### 9.1 ÌôòÍ≤Ω ÏÑ§Ï†ï
```bash
# .env ÌååÏùº
KOREA_INVESTMENT_APP_KEY=your_app_key
KOREA_INVESTMENT_APP_SECRET=your_app_secret
CACHE_TTL_SECONDS=5
LOG_LEVEL=INFO
MAX_RETRY_ATTEMPTS=3
RATE_LIMIT_PER_MINUTE=100
```

### 9.2 Docker ÏÑ§Ï†ï
```dockerfile
# Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["python", "-m", "src.server"]
```

### 9.3 Ïã§Ìñâ Î∞©Î≤ï
```bash
# Í∞úÎ∞ú ÌôòÍ≤Ω
python -m src.server

# Docker
docker build -t mcp-market-index .
docker run -p 8080:8080 --env-file .env mcp-market-index

# Docker Compose
docker-compose up -d
```

## 10. Î™®ÎãàÌÑ∞ÎßÅ Î∞è Ïú†ÏßÄÎ≥¥Ïàò

### 10.1 Î°úÍπÖ ÏÑ§Ï†ï
```python
# src/utils/logger.py
import logging
import sys
from datetime import datetime

def setup_logger(name: str, level: str = "INFO") -> logging.Logger:
    """Î°úÍ±∞ ÏÑ§Ï†ï"""
    logger = logging.getLogger(name)
    logger.setLevel(getattr(logging, level))
    
    # ÏΩòÏÜî Ìï∏Îì§Îü¨
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(logging.INFO)
    
    # ÌååÏùº Ìï∏Îì§Îü¨
    file_handler = logging.FileHandler(
        f"logs/{name}_{datetime.now().strftime('%Y%m%d')}.log"
    )
    file_handler.setLevel(logging.DEBUG)
    
    # Ìè¨Îß∑ÌÑ∞
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    console_handler.setFormatter(formatter)
    file_handler.setFormatter(formatter)
    
    logger.addHandler(console_handler)
    logger.addHandler(file_handler)
    
    return logger
```

### 10.2 Î©îÌä∏Î¶≠ ÏàòÏßë
```python
# src/utils/metrics.py
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List

@dataclass
class APIMetric:
    endpoint: str
    response_time: float
    status_code: int
    timestamp: datetime
    
class MetricsCollector:
    def __init__(self):
        self.metrics: List[APIMetric] = []
        
    def record_api_call(
        self, 
        endpoint: str, 
        response_time: float, 
        status_code: int
    ):
        """API Ìò∏Ï∂ú Î©îÌä∏Î¶≠ Í∏∞Î°ù"""
        metric = APIMetric(
            endpoint=endpoint,
            response_time=response_time,
            status_code=status_code,
            timestamp=datetime.now()
        )
        self.metrics.append(metric)
        
    def get_stats(self) -> Dict:
        """ÌÜµÍ≥Ñ Î∞òÌôò"""
        if not self.metrics:
            return {}
            
        total_calls = len(self.metrics)
        avg_response_time = sum(m.response_time for m in self.metrics) / total_calls
        error_rate = sum(1 for m in self.metrics if m.status_code >= 400) / total_calls
        
        return {
            'total_calls': total_calls,
            'avg_response_time': avg_response_time,
            'error_rate': error_rate * 100,
            'last_call': self.metrics[-1].timestamp
        }
```

### 10.3 ÏïåÎ¶º ÏÑ§Ï†ï
- API Ïû•Ïï† Í∞êÏßÄ
- ÎπÑÏ†ïÏÉÅ Îç∞Ïù¥ÌÑ∞ Í∞êÏßÄ
- Ï∫êÏãú Î©îÎ™®Î¶¨ ÏÇ¨Ïö©Îüâ
- Rate Limit ÎèÑÎã¨ Í≤ΩÍ≥†

## 11. Î≥¥Ïïà Í≥†Î†§ÏÇ¨Ìï≠

### 11.1 API ÌÇ§ Í¥ÄÎ¶¨
- ÌôòÍ≤Ω Î≥ÄÏàòÎ°ú ÎØºÍ∞ê Ï†ïÎ≥¥ Î∂ÑÎ¶¨
- `.env` ÌååÏùº git ignore
- ÌÇ§ Î°úÌÖåÏù¥ÏÖò Ï£ºÍ∏∞ ÏÑ§Ï†ï

### 11.2 ÏöîÏ≤≠ Í≤ÄÏ¶ù
- ÏûÖÎ†• ÌååÎùºÎØ∏ÌÑ∞ Í≤ÄÏ¶ù
- SQL Injection Î∞©ÏßÄ
- Rate Limiting Íµ¨ÌòÑ

### 11.3 ÌÜµÏã† Î≥¥Ïïà
- HTTPS ÏÇ¨Ïö©
- API ÏùëÎãµ Îç∞Ïù¥ÌÑ∞ ÏïîÌò∏Ìôî
- Î°úÍ∑∏Ïóê ÎØºÍ∞ê Ï†ïÎ≥¥ Ï†úÏô∏

Ïù¥ Í≥ÑÌöçÏÑúÎ•º ÌÜµÌï¥ ÏïàÏ†ïÏ†ÅÏù¥Í≥† Ìö®Ïú®Ï†ÅÏù∏ ÏãúÏû• ÏßÄÏàò MCP ÏÑúÎ≤ÑÎ•º Íµ¨Ï∂ïÌï† Ïàò ÏûàÏäµÎãàÎã§.